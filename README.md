## Java高并发秒杀项目

项目安装见博客：[Java高并发秒杀项目](https://blog.csdn.net/nageaixiaodenanhai/article/details/105412877)

项目地址：http://39.106.104.91:8080/login/to_login  登录手机号：15010058964  密码：123456

#### 项目介绍

基于Springboot+Mybatis搭建的电商秒杀系统，对高并发场景进行了优化，在保证线程安全的同时也提高了对系统的并发访问量。主要优化手段有Redis缓存（页面缓存，对象缓存）、页面静态化、RabbitMQ异步下单。项目的主要功能流程为登录-->浏览商品-->查看商品详情-->下订单-->付款或返回。本系统使用jmeter工具进行压测，对比优化之前和优化之后系统提高的并发访问量。

#### 系统设计

##### 1.登录功能

用户使用手机号和密码进行登录并实现了分布式session。密码使用两次md5+salt(盐化)，第一次是前端使用固定salt值结合password进行一次MD5传到后台，是为了防止明文密码在网络中传输被窃取。数据传到后台之后用手机号验证用户是否存在，如果存在返回数据库中的salt，与前端传来的password（经过一次MD5）结合再次MD5，然后进行比较。密码相同则生成token，将token作为key，用户信息作为value存储到redis缓存中，同时将token返回到浏览器中缓存，以此来实现登录功能中的分布式session。

##### 2.商品展示功能

这里并没有复杂的业务逻辑，单纯的三个展示页面，商品列表页，商品详情页，订单详情页。

##### 3.秒杀功能

秒杀功能的主要逻辑为判断用户是否登录-->判断是否还有库存-->判断用户是否已经秒杀到-->减库存、下订单、写入秒杀订单。当大量用户访问时，要满足高并发的秒杀场景，解决超卖等问题。

##### 4.防刷功能

利用动态地址，图形验证码，秒杀订单点击频率来防止用户使用刷单软件刷单。

##### 5.数据库

数据库的主要设计为五张表：goods、miaosha_goods、miaosha_user、miaosha_order、order_info。数据库生成语句在sql生成文件.txt中。

#### 系统优化

##### 1.页面缓存

访问商品列表页面时，不是让系统渲染页面，而是从缓存里面取，如果找到返回客户端，如果没有，手动渲染模板，渲染出来之后，把结果输出给客户端，同时把结果缓存到redis里面来，下次就可以使用了。（1.取缓存2.手动渲染模板3.结果输出）缓存是为了避免瞬间访问太多导致服务器压力太大，但是如果说缓存时间太长，数据的及时性就不高了。缓存时间设置在合适的范围。

##### 2.对象缓存

将用户信息设置缓存，缓存用户信息时必须考虑缓存数据和数据库数据保持一致。当用户信息修改时，先修改数据库中的数据，再处理缓存（使缓存失效）。

##### 3.页面静态化

上述的两种缓存，都是利用redis缓存服务器来实现的，虽然可以降低对数据库和服务器的压力，但是，redis服务器的容量和处理能力也是有限的，所以我们可以考虑将页面模板直接缓存到用户的浏览器，那么每次请求用户只需要请求用于渲染的对象即可，这不仅仅减轻了redis服务器的压力，同时也减少了带宽的消耗，此即为页面静态化。 在本项目中，主要实现的是商品详情、订单详情页面、秒杀页面的静态化，主要方法是利用ajax的异步加载，请求渲染需要的对象，并且通过配置 spring.resources的相关参数来告诉浏览器是否缓存，缓存有效时间等等。 

##### 4.接口优化

Redis预减库存减少数据库访问，内存标记减少Redis访问，请求先入队缓冲，异步下单，增强用户体验。

##### 5.解决超卖

在秒杀订单表中建立用户id和商品id的联合唯一索引。SQL语句优化，获取库存时设置条件stock_count > 0时才进行减库存。 

##### 6.静态资源优化

JS/CSS压缩，减少流量。多个JS/CSS组合，减少连接数。 CDN就近访问等。

#### 系统测试

##### 1.测试环境

服务器:(Mysq、Redis服务也均安装在本机上 ，RabbitMQ安装在远程服务器上）

内存： 8G 

Java版本：1.8.0_161 Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)  

MySQL：5.7.28-log MySQL Community Server (GPL)  

Redis：3.0.504 

##### 2.测试方法

测试工具使用Jmeter并发测试工具，为保证无非相关变量的影响，每次测试的并发线程数均设为1000，并发时间1s，并发循环次数为10次，如图所示： 

![1586570877041](C:\Users\sutian\AppData\Local\Temp\1586570877041.png)

 对goods/to_list进行压测

优化前

![1586570917972](C:\Users\sutian\AppData\Local\Temp\1586570917972.png)

优化后

![1586570934300](C:\Users\sutian\AppData\Local\Temp\1586570934300.png)

对于上图的两个测试，我们比较关注的是聚合报告里的 ThoughPut 的值，其值可以作为吞吐量的一个较好估计。  由图可见：  

优化前，系统吞吐量为：729.9/sec  

优化后，系统吞吐量为：2209.0/sec  

也就意味着，加速比为：3.03

 

对goods/detail/{goodsId}进行压测

优化前

![1586571933233](C:\Users\sutian\AppData\Local\Temp\1586571933233.png)

优化后

![1586571953624](C:\Users\sutian\AppData\Local\Temp\1586571953624.png)

通过比以上两图，会发现，似乎区别不是特别明显，很容易让人觉得优化没有太大的作用，其实不然 ，这种情况应该是由Jmeter自身导致的，因为Jmeter做测试的时候并不会依赖于其他浏览器，只是发起http请求，而浏览器所具备的一些功能Jemter并没有，比如，缓存，利用Jmeter进行测试并不能得出一个如意的结果，但是，我们可以通过浏览器来大致的了解页面静态化后的一些改变。如图： 

![1586572207379](C:\Users\sutian\AppData\Local\Temp\1586572207379.png)

可以清楚的看到，这个页面大部分的内容都被“已缓存”，只有700多个字节的对象被请求并传输，比之前传输整个html页面的大小小很多，这也就达到了我们优化前的目的了。 

对秒杀接口做压测

对于接口测试，我实现准备了1000个user和cookie，具体脚本见src/main/java/com/imooc/miaosha/util/UserUtil.java下的代码，在Jmeter中使用参数方法可自行百度，如图： 

![1586572602506](C:\Users\sutian\AppData\Local\Temp\1586572602506.png)

对于秒杀接口，我们只对优化后的接口进行压测，测试的情况分为两类：

1、秒杀库存充足

2、秒杀库存不足

对于秒杀库存充足的情况，我们设置初始的库存为200，然后，并发量和其他测试设置一致，结果如图：

![1586572790030](C:\Users\sutian\AppData\Local\Temp\1586572790030.png)

对于秒杀库存不足的情况，我们设置初始的库存为0，然后，并发量和其他测试设置一致，结果如图： 

![1586572859251](C:\Users\sutian\AppData\Local\Temp\1586572859251.png)

对于处理逻辑比较复杂的接口而言，最好和最坏的情况能达到这样的一个吞吐量，同时保证线程安全性，比较满意。 